<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var types = new[] { "int", "long" };
    var maxWidths = new[] { sizeof(int) * 8, sizeof(long) * 8 };

    long genMask(int bitWidth) {  
        long mask = 0;
        for (int i = 0; i < bitWidth; i++) {
          mask <<= 1;
          mask |= 1;
        }
        return mask;
    }

    int paddedByteCountFromBits(int bitLength) {
        return (bitLength + 7) / 8;
    }

    Tuple<int, long> getShiftMask(int bitWidth, bool msbFirst,
        int byteIndex, int valueIndex) {

        // relative positions of the start and end of the value to the start and end of the byte
        int valueStartBitIndex = (valueIndex * bitWidth) - (8 * (byteIndex));
        int valueEndBitIndex = ((valueIndex + 1) * bitWidth) - (8 * (byteIndex + 1));

        // boundaries of the current value that we want
        int valueStartBitWanted;
        int valueEndBitWanted;
        // boundaries of the current byte that will receive them
        int byteStartBitWanted;
        int byteEndBitWanted;

        int shift;
        int widthWanted;

        if (msbFirst) {
            valueStartBitWanted = valueStartBitIndex < 0 ? bitWidth - 1 + valueStartBitIndex : bitWidth - 1;
            valueEndBitWanted = valueEndBitIndex > 0 ? valueEndBitIndex : 0;
            byteStartBitWanted = valueStartBitIndex < 0 ? 8 : 7 - valueStartBitIndex;
            byteEndBitWanted = valueEndBitIndex > 0 ? 0 : -valueEndBitIndex;
            shift = valueEndBitWanted - byteEndBitWanted;
            widthWanted = Math.Min(7, byteStartBitWanted) - Math.Min(7, byteEndBitWanted) + 1;
        } else {
            valueStartBitWanted = bitWidth - 1 - (valueEndBitIndex > 0 ? valueEndBitIndex : 0);
            valueEndBitWanted = bitWidth - 1 - (valueStartBitIndex < 0 ? bitWidth - 1 + valueStartBitIndex : bitWidth - 1);
            byteStartBitWanted = 7 - (valueEndBitIndex > 0 ? 0 : -valueEndBitIndex);
            byteEndBitWanted = 7 - (valueStartBitIndex < 0 ? 8 : 7 - valueStartBitIndex);
            shift = valueStartBitWanted - byteStartBitWanted;
            widthWanted = Math.Max(0, byteStartBitWanted) - Math.Max(0, byteEndBitWanted) + 1;
        }

        int maskWidth = widthWanted + Math.Max(0, shift);

        return Tuple.Create(shift, genMask(maskWidth));
    }

#>
namespace Parquet.Encodings {
    using System;

    static partial class BitPackedEncoder {

        public static void Pack8Values(Span<int> src, Span<byte> dest, int bitWidth) {
        <# for(int i = 0; i < sizeof(int) * 8; i++) { 
            #>    <#if(i == 0) {#><#} else {#>else <#} #>if(bitWidth == <#= i #>)
                IntPack8Values_<#= i #>(src, dest);
        <#} #>
        }

        public static void Unpack8Values(Span<byte> src, Span<int> dest, int bitWidth) {
        <# for(int i = 0; i < sizeof(int) * 8; i++) { 
            #>    <#if(i == 0) {#><#} else {#>else <#} #>if(bitWidth == <#= i #>)
                IntUnpack8Values_<#= i #>(src, dest);
        <#} #>
        }

        public static void Pack8Values(Span<long> src, Span<byte> dest, int bitWidth) {
        <# for(int i = 0; i < sizeof(long) * 8; i++) { 
            #>    <#if(i == 0) {#><#} else {#>else <#} #>if(bitWidth == <#= i #>)
                LongPack8Values_<#= i #>(src, dest);
        <#} #>
        }

        public static void Unpack8Values(Span<byte> src, Span<long> dest, int bitWidth) {
        <# for(int i = 0; i < sizeof(long) * 8; i++) { 
            #>    <#if(i == 0) {#><#} else {#>else <#} #>if(bitWidth == <#= i #>)
                LongUnpack8Values_<#= i #>(src, dest);
        <#} #>
        }

<# for(int i = 0; i < types.Length; i++) { 
    string nt = types[i];
    int maxWidth = maxWidths[i];
    string ntCap = nt.Substring(0, 1).ToUpper() + nt.Substring(1);
    string maskName = "ShiftMask" + ntCap;
    
    for(int w = 0; w < maxWidth; w++) {
 #>
        private static void <#= ntCap #>Unpack8Values_<#= w #>(Span<byte> src, Span<<#= nt #>> dest) {
        <# if(w > 0) {
            for (int valueIndex = 0; valueIndex < 8; ++valueIndex) { 
                int startIndex = valueIndex * w / 8;
                int endIndex = paddedByteCountFromBits((valueIndex + 1) * w);
            #>
            dest[<#= valueIndex #>] = <#

                for (int byteIndex = startIndex; byteIndex < endIndex; byteIndex++) {
                    if(byteIndex == startIndex) {#><#} else {#> | <#}

                    var shiftMask = getShiftMask(w, false, byteIndex, valueIndex);
                    var ss = "";

                    if(shiftMask.Item1 < 0) {
                        ss = " >> " + (- shiftMask.Item1);
                    } else if(shiftMask.Item1 > 0) {
                        ss = " << " + shiftMask.Item1;
                    }

                    #>((((<#= nt #>)src[<#= byteIndex #>])<#= ss #>) & <#= shiftMask.Item2 #>)<#
                }

            #>;<#
            }
        } else { #> <#} #>
        }

        private static void <#= ntCap #>Pack8Values_<#= w #>(Span<<#= nt #>> src, Span<byte> dest) {
        <#
            long mask = genMask(w);
            for (int byteIndex = 0; byteIndex < w; ++byteIndex) { #>
            dest[<#= byteIndex #>] = 
                (byte)((<#
                int startIndex = (byteIndex * 8) / w;
                int endIndex = ((byteIndex + 1) * 8 + w - 1) / w;
                for (int valueIndex = startIndex; valueIndex < endIndex; valueIndex++) {
                    var shiftMask = getShiftMask(w, false, byteIndex, valueIndex);
                    var ss = "";
                    if(shiftMask.Item1 > 0) {
                        ss = " >> " + shiftMask.Item1;
                    } else if(shiftMask.Item1 < 0) {
                        ss = " << " + (-shiftMask.Item1);
                    }

                    if(valueIndex == startIndex) {#><#} else {#>
                | <#}

                    #>((src[<#= valueIndex #>] & <#= mask #>)<#= ss #>)<#
                } // for valueIndex
                #>) & 255);
                <#
            } // for byteIndex
         #>
        } // method

<#
    } // for w
} // for types
#>
    } // class
} // ns