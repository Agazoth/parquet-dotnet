<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var types = new[] { "bool?", "byte?", "sbyte?", "short?", "ushort?", "int?", "uint?", "long?", "ulong?", "BigInteger?", "float?", "double?", "decimal?", "DateTime?", "TimeSpan?", "Interval?", "string", "byte[]" }; #>
// This file is generated with T4
// https://learn.microsoft.com/en-us/visualstudio/modeling/text-template-control-blocks?view=vs-2022
// Because of this, performance is truly great!
// Hint: prefer Rider to edit .tt as it support syntax highlighting
namespace Parquet.Extensions {

    using System;
    using System.Numerics;
    using Parquet.File.Values.Primitives;

    static class UntypedArrayExtensions {

        #region [ Null Counting ]

        public static int CalculateNullCountFast(this Array array, int offset, int count) {
            Type t = array.GetType().GetElementType();
            if(!t.IsNullable()) return 0;

<# foreach(string nt in types) { #>
            if(t == typeof(<#= nt #>)) {
                return CalculateNullCount((<#= nt #>[])array, offset, count);
            }
<# } #>            
            throw new NotSupportedException($"cannot count nulls in type {t}");
        }

<# foreach(string nt in types) { #>
        private static int CalculateNullCount(<#= nt #>[] array, int offset, int count) {
            int r = 0;
            for(int i = offset; i < count; i++) {
                if(array[i] == null) {
                    r++;
                }
            }
            return r;
        }
<# } #>
    #endregion

    #region [ Null Packing ]

    public static void PackNullsFast(this Array array,
            int offset, int count,
            Array packedData,
            Span<int> dest,
            int fillerValue) {

            Type t = array.GetType().GetElementType();
            if(!t.IsNullable()) return;

<# foreach(string nt in types) { #>
            if(t == typeof(<#= nt #>)) {
                PackNulls((<#= nt #>[])array,
                    offset, count,
                    (<#= nt #>[])packedData,
                    dest, fillerValue);
            }
<# } #>            
            throw new NotSupportedException($"cannot pack type {t}");
        }

<# foreach(string nt in types) { #>
        private static void PackNulls(<#= nt #>[] array,
            int offset, int count,
            <#= nt #>[] packedArray,
            Span<int> dest,
            int fillerValue) {

            for(int i = offset, y = 0, ir = 0; i < (offset + count); i++, y++) {
                <#= nt #> value = array[i];

                if(value == null) {
                    dest[y] = 0;
                }
                else {
                    dest[y] = fillerValue;
                    packedArray[ir++] = value;
                }
            }
        }

<# } #>

    #endregion

    #region [ Null Unpacking ]

    public static void UnpackNullsFast(this Array array,
        int[] flags, int fillFlag,
        Array result) {

        Type t = array.GetType().GetElementType();
        
<# foreach(string nt in types) { #>
<# string nnt = nt.EndsWith("?") ? nt.Substring(0, nt.Length - 1) : nt; #>
        if(t == typeof(<#= nnt #>)) {
            UnpackNulls((<#= nnt #>[])array,
                flags, fillFlag,
                (<#= nt #>[])result);
            return;
        }
<# } #>            
        throw new NotSupportedException($"cannot pack type {t}");

    }

<# foreach(string nt in types) { #>
<# string nnt = nt.EndsWith("?") ? nt.Substring(0, nt.Length - 1) : nt; #>
    private static void UnpackNulls(<#= nnt #>[] array,
        int[] flags, int fillFlag,
        <#= nt #>[] result) {

        int iarray = 0;
        for(int i = 0; i < flags.Length; i++) {
            int level = flags[i];

            if(level == fillFlag) {
                result[i] = array[iarray++];
            }
        }
    }

<# } #>

    #endregion

    #region [ Dictionary Explosion ]

    public static void ExplodeFast(this Array dictionary,
            Span<int> indexes,
            Array result, int resultOffset, int resultCount) {

    }

    #endregion

    }
}